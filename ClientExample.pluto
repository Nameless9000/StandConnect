--
-- StandConnect Client Example
--
--
-- MIT No Attribution
--
-- Copyright 2024 Nameless9000
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this
-- software and associated documentation files (the "Software"), to deal in the Software
-- without restriction, including without limitation the rights to use, copy, modify,
-- merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
-- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-- OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--
assert = function(condition, message) -- kill script on assert
	if condition then return end
	util.log("Error: "..message)
	util.stop_script()
end

local { socket, bigint, crypto, json, base64 } = require "pluto:*"

-- Connect to server
local port = 42658
util.toast("Connecting to port "..port)
local c = socket.connect("127.0.0.1", port)
assert(c, "failed to bind tcp")
util.keep_running()

-- Load server config
local data = c:recv()
assert(data, "server closed connection")

local [RSA_BITS, SERVER_EXPONENT, SERVER_MODULUS] = data:split(":")
assert(RSA_BITS, "server provided invalid data")
assert(SERVER_EXPONENT, "server provided invalid data")
assert(SERVER_MODULUS, "server provided invalid data")

local SERVER_PUB_KEY = {
	n = new bigint(SERVER_MODULUS),
	e = new bigint(SERVER_EXPONENT),
}

-- Generate our key pair
local RSA_PUBLIC_KEY, RSA_PRIVATE_KEY = crypto.generatekeypair("rsa", RSA_BITS)

-- State
local can_continue = false
local secret_code = ""

-- Code prompt
local code_prompt = menu.my_root():action("code", {"standconnectcode"}, "", function()
	menu.show_command_box("standconnectcode ")
end, function(code)
	secret_code = code
	can_continue = true
end)

-- Send the server our config
c:send($"{RSA_PUBLIC_KEY.e:tostring()}:{RSA_PUBLIC_KEY.n:tostring()}")

-- Check if we are allowed to continue
local allowed = c:recv()
assert(allowed, "Connection request was denied")

menu.show_command_box("standconnectcode ")

-- Get code input
while not can_continue do
	util.yield(100)
end
code_prompt:delete()

-- Send the encrypted code
c:send(crypto.encrypt(secret_code, "rsa-pkcs1", SERVER_PUB_KEY))

-- Get the encryption key
local data = c:recv()
assert(data, "server closed connection")

local decrypted_key = crypto.decrypt(data, "rsa-pkcs1", RSA_PRIVATE_KEY)
local [ enc_iv, enc_key ] = decrypted_key:split(":")

-- Create helper functions
local function encrypt(plaintext)
	return base64.encode(crypto.encrypt(plaintext, "aes-cbc-pkcs7", enc_key, enc_iv))
end

local function decrypt(encrypted)
	return crypto.decrypt(base64.decode(encrypted), "aes-cbc-pkcs7", enc_key, enc_iv)
end

local function server_exec(lua)
	c:send(encrypt(lua))
	local res = decrypt(c:recv())
	local decoded = json.decode(res)
	if not decoded or #decoded < 1 then
		return
	end
	
	return decoded[1]
end

-- Make an execution prompt
menu.my_root():action("execution", {"standconnectexec"}, "", function()
	menu.show_command_box("standconnectexec ")
end, function(lua)
	local result = server_exec(lua)

	util.log($"StandConnect Client Output: {tostring(result)}")
end):focus()
