--###########################################################################
-- 
-- StandConnect - A script to facilitate secure connections to the stand mod menu
-- 
--###########################################################################
--
--	Credits:
--		Nameless9000 - Creator
--
--###########################################################################
--
-- MIT No Attribution
--
-- Copyright 2024 Nameless9000
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this
-- software and associated documentation files (the "Software"), to deal in the Software
-- without restriction, including without limitation the rights to use, copy, modify,
-- merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
-- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-- OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--
--###########################################################################
---CONFIG
--###########################################################################
--
-- [CONNECTION CONFIG] --
$define MAX_CONNECTIONS = 5
$define PORT = 42658
--
-- [SECURITY CONFIG] --
$define RSA_BITS = 1024
--
--###########################################################################
--------- CODE - DO NOT TOUCH IF YOU DO NOT KNOW WHAT YOU ARE DOING ---------
--###########################################################################
--
--[[
##### PROTOCOL DESIGN #####

-- CONNECTION OPEN --
	SERVER: <RSA_BITS>:<RSA PUBLIC EXPONENT>:<RSA PUBLIC MODULUS>
	CLIENT: <RSA PUBLIC EXPONENT>:<RSA PUBLIC MODULUS>
	
#A secret code is displayed to the user
	SERVER: READY
	CLIENT: <secret code is encrypted with server's public key>
#The code is verified

#The server generates an encryption key to be used
	SERVER: <new aes-cbc-pkcs7 encryption key (iv:key), encrypted with client's public key>
	
#The all messages from now will be encrypted with that key, server will respond with JSON

	CLIENT: util.toast("Success!")
	SERVER: null
	
	CLIENT: return 2 + 2
	SERVER: 4

-- CONNECTION CLOSE --
]]
--

--########################################--
--MAIN DECLARATIONS
--########################################--

pluto_use "0.9.4"

local { socket, bigint, crypto, json, base64 } = require "pluto:*"
local listener

--########################################--
--INITIALIZE CONSTANTS
--########################################--

local RSA_PUBLIC_KEY, RSA_PRIVATE_KEY = crypto.generatekeypair("rsa", RSA_BITS)

--########################################--
--SHARED CONNECTION DATA
--########################################--

local connection_count = 0
local connections_allowed = true

--########################################--
--UTIL FUNCTIONS
--########################################--


-- A simple macro to create alerts
local function ALERT(message: string)
	util.toast("[StandConnect]: "..message, TOAST_ALL)
end


-- A simple macro to log events
local function LOG(message: string)
	util.toast("[StandConnect]: "..message, TOAST_LOGGER)
end


-- Function to run lua code at runtime
local function load(lua: string)
	local store_dir = filesystem.store_dir()
	local scripts_dir = store_dir .. "\\StandConnect\\"
	
	if not filesystem.exists(scripts_dir) then
		filesystem.mkdir(scripts_dir)
	end
	
	local filepath = $"{scripts_dir}StandConnect-{crypto.sha1(lua)}.pluto"
	if not filesystem.exists(filepath) then
		file = io.open(filepath, "w")
		file:write(lua)
		file:close()
	end
	
	return dofile(filepath)
end


--########################################--
--CREATE UI
--########################################--


local UI_ROOT = menu.my_root()

-- Toggle to globally disable connections
local TOGGLE_DISABLE_CONNECTIONS = UI_ROOT:toggle("Disable Connections", {}, "", function(toggle)
	connections_allowed = toggle
end)


--########################################--
--SECURITY PROMPT
--########################################--


-- Blocking prompt state
local IS_PROMPT_ACTIVE = false


-- Function to create confirmation prompts
local function create_confirmation_prompt(message: string, redirect = menu.get_current_menu_list(), times_required = 3): boolean <nodiscard>
	-- Lock to prevent multiple prompts
	while IS_PROMPT_ACTIVE do
		util.yield(100)
	end
	IS_PROMPT_ACTIVE = true

	-- Make prompt
	local prompt
	prompt = menu.ref_by_path("Stand"):list("StandConnect Security", {}, "", nil, function()
		prompt:focus()
	end)
	
	prompt:divider("[StandConnect Security]")
	prompt:divider(message)
	
	-- Prompt state
	local active = true
	local result = false
	local times_agreed = 0
	
	-- Options
	local option_yes
	option_yes = prompt:action($"Yes ({times_required})", {}, "", function()
		times_agreed += 1
		if times_agreed >= times_required then
			result = true
			active = false
			return
		end
		
		option_yes.menu_name = $"Are you sure? ({times_required - times_agreed})"
	end)
	local option_no = prompt:action("No", {}, "", function()
		active = false
	end)

	option_no:focus()

	-- Keep thread blocked until response
	while active do
		-- force user in prompt
		if not option_no:isFocused() and not option_yes:isFocused() then
			option_no:focus()
		end
		util.yield(100)
	end
	
	-- Cleanup
	IS_PROMPT_ACTIVE = false
	redirect:focus()
	menu.default_and_delete(prompt)
	
	-- Logging
	if result then
		LOG("Prompt '"..message.."' was allowed")
	else
		LOG("Prompt '"..message.."' was denied")
	end
	
	return result
end


--########################################--
--ENUMS
--########################################--


enum AUTH_STATUS begin
	OK,
	INVALID_KEY,
	BAD_REQUEST,
	REQUEST_DENIED,
	CLIENT_CLOSE
end


--########################################--
--PROCESS AUTHENTICATION
--########################################--


-- Function to handle the authorization of connections
local SERVER_CONFIG_MESSAGE = $"{RSA_BITS}:{RSA_PUBLIC_KEY.e:tostring()}:{RSA_PUBLIC_KEY.n:tostring()}"
local function handle_auth(id: number, connection: userdata) <nodiscard>
	-- Send our config
	connection:send(SERVER_CONFIG_MESSAGE)
	
	-- Recieve client's key
	local data = connection:recv()
	if not data then
		return AUTH_STATUS.CLIENT_CLOSE
	end
	
	-- Parse client pub key
	local [CLIENT_EXPONENT, CLIENT_MODULUS] = data:split(":")
	if CLIENT_EXPONENT == nil or CLIENT_MODULUS == nil then
		return AUTH_STATUS.BAD_REQUEST
	end

	local CLIENT_PUB_KEY = {
		n = new bigint(CLIENT_MODULUS),
		e = new bigint(CLIENT_EXPONENT),
	}
	
	if CLIENT_PUB_KEY.n:bitlength() ~= RSA_BITS then
		return AUTH_STATUS.BAD_REQUEST
	end
	
	-- Generate secret code
	local SECRET_CODE = crypto.random(1000000, 9999999)
	
	-- Check for continue
	local should_continue = create_confirmation_prompt($"Your code is: {SECRET_CODE}, do you want to connect?")
	if not should_continue then
		return AUTH_STATUS.REQUEST_DENIED
	end
	
	-- Send ready signal
	connection:send("READY")
	
	-- Recieve client's attempt
	local key_confirmation = connection:recv()
	if not key_confirmation then
		return AUTH_STATUS.CLIENT_CLOSE
	end
	
	-- Decrypt and check key
	local decrypted_key = crypto.decrypt(key_confirmation, "rsa-pkcs1", RSA_PRIVATE_KEY)
	if decrypted_key ~= tostring(SECRET_CODE) then
		return AUTH_STATUS.INVALID_KEY
	end
	
	ALERT($"Connection {id} was authorized")
	
	-- Generate encryption key
	local enc_key = range(32):map(|| -> string.char(crypto.random(0, 255))):concat("")
	local enc_iv = range(16):map(|| -> string.char(crypto.random(0, 255))):concat("")
	
	local encrypted_key = crypto.encrypt($"{enc_iv}:{enc_key}", "rsa-pkcs1", CLIENT_PUB_KEY)
	connection:send(encrypted_key)
	
	-- Make helper functions for encrypt and decrypt
	local function encrypt(plaintext)
		return base64.encode(crypto.encrypt(plaintext, "aes-cbc-pkcs7", enc_key, enc_iv))
	end

	local function decrypt(encrypted)
		return crypto.decrypt(base64.decode(encrypted), "aes-cbc-pkcs7", enc_key, enc_iv)
	end
	
	return AUTH_STATUS.OK, encrypt, decrypt
end


--########################################--
--PROCESS REQUESTS
--########################################--


-- Function to handle connections
local function handle_connection(id: number, connection: userdata): void
	-- authorization checks
	local authorized, encrypt, decrypt = handle_auth(id, connection)
	if authorized ~= AUTH_STATUS.OK then
		ALERT("Authorization failed with error code: "..authorized)
		return
	end
	
	-- handle execution
	while connection do
		local data = connection:recv()
		if not data then
			return
		end
		
		-- Decrypt user data
		local code = decrypt(data)
		if not code then
			LOG($"Connection {id} sent invalid data")
			continue
		end
		
		LOG($"Connection {id} sent execution request")
		
		-- Execute the code
		local response = nil
		try
			response = load(code)
		catch err then
			LOG($"Connection {id}: {err}")
			continue
		end
		
		-- it works..
		local encoded = json.encode({response})
		connection:send(encrypt(encoded))
	end
end


--########################################--
--START THREADS
--########################################--


-- Function thread to handle the processing of new connections
local function connection_thread(): void
	while true do
		if not connections_allowed then
			util.yield(100)
			continue
		end
	
		while not listener:hasconnection() do
			util.yield(10)
		end

		-- accept connection
		local connection = listener:accept()
		if not connection then
			continue
		end
		connection_count += 1
		ALERT("Connection "..connection_count.." connected")
		
		-- connected
		handle_connection(connection_count, connection)
		
		-- disconnected
		ALERT("Connection "..connection_count.." disconnected")
		connection:close()
		connection_count -= 1
	end
end


--########################################--
--START THREADS
--########################################--


listener = socket.listen(PORT)
assert(listener, "failed to bind tcp/"..PORT)

for thread = 1, MAX_CONNECTIONS do
	util.create_thread(connection_thread)
end
